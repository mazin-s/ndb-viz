import os
import shutil
import sys
import math
from typing import Any, Union, NamedTuple, Literal
import plotly.express as px
import plotly.graph_objs as go
import re
import json
from plotly.utils import PlotlyJSONEncoder


class NodeInfo(NamedTuple):
    """
    Info about a node in the treemap (file or dir)
    """

    lines: int
    code: int
    comments: int
    blanks: int
    logs: int

    def __add__(self, ni):
        if not isinstance(ni, NodeInfo):
            raise Exception("wrong")
        return NodeInfo(
            lines=self.lines + ni.lines,
            code=self.code + ni.code,
            comments=self.comments + ni.comments,
            blanks=self.blanks + ni.blanks,
            logs=self.logs + ni.logs,
        )

    @staticmethod
    def new():
        return NodeInfo(lines=0, code=0, comments=0, blanks=0, logs=0)


class PlotData(NamedTuple):
    """
    Lists needed to construct treemap
    """

    ids: list[str]
    names: list[str]
    parents: list[str]
    infos: list[NodeInfo]

    @staticmethod
    def new():
        return PlotData(ids=[], names=[], parents=[], infos=[])


class CodeQualityAnalyzer:
    """
    A helper tool to reason about code quality from looking at % of
    comments and log statments. Assumes that a nice and pretty outfile
    has already been generated by a tool in a better language (rust)
    """

    def __init__(
        self,
        data_file: str,
        base_path: str,
        extensions: list[str],
        verbose=True,
    ):
        """
        Initializes and performs the analysis. Once complete, can be served
        :param str base_path: The base path (folder) to analyze
        :param list[str] exclude_dirs: Directories that will be ignored in
                analysis
        """
        # Generate the hierachy and extract data
        if verbose:
            print("Generating hierarchy...")
        with open(data_file) as fin:
            lines = fin.readlines()
        lines = lines[3:-3]  # Include only the meat of report
        self.ext2path2data: dict[str, dict[str, NodeInfo]] = {k: {} for k in extensions}
        # For loop goes over each line, extracts info, and stores info dicts per-extension
        for line in lines:
            parts = re.split(r"\s{2,}", line)
            if len(parts) != 6:
                # Ignore spacing lines
                continue
            (path, num_lines, code, comments, blanks, logs) = parts
            path = path[1:]  # Get rid of weird space at front
            if not path.startswith(base_path):
                # Ignore language description lines
                continue
            path = path[len(base_path) :]
            node_info = NodeInfo(
                lines=int(num_lines),
                code=int(code),
                comments=int(comments),
                blanks=int(blanks),
                logs=int(logs),
            )
            ext = path.split(".")[-1]
            if "*" not in extensions and ext not in extensions:
                # Ignore file extensions not explicitly asked for
                continue
            if "*" in extensions:
                self.ext2path2data["*"][path] = node_info
            if ext in extensions:
                self.ext2path2data[ext][path] = node_info
        # Construct the hierarchies on a per-extension basis
        self.ext2hierarchy = {k: {} for k in self.ext2path2data}
        for ext in self.ext2hierarchy:
            paths = list(self.ext2path2data[ext].keys())
            for file in paths:
                parts = file.split("/")
                last_data = self.ext2hierarchy[ext]
                for part in parts:
                    if part not in last_data:
                        last_data[part] = {}
                    last_data = last_data[part]
        # Make the arrays needed for plotly
        self.ext2plotdata = {k: PlotData.new() for k in self.ext2hierarchy}
        self.counts: dict[str, int] = {}
        for ext in self.ext2hierarchy:
            self._internal_construct_ext(ext)

    def _internal_construct_ext(self, ext):
        self.recursively_construct(
            self.ext2hierarchy[ext],
            "",
            "root",
            self.ext2path2data[ext],
            self.ext2plotdata[ext],
        )
        self.ext2plotdata[ext].ids.append("root")
        self.ext2plotdata[ext].names.append("root")
        self.ext2plotdata[ext].parents.append("")
        self.ext2plotdata[ext].infos.append(NodeInfo.new())

    def recursively_construct(
        self,
        subdata: dict[str, Any],
        path: str,
        parent_name: str,
        path2data: dict[str, NodeInfo],
        plot_data: PlotData,
    ) -> NodeInfo:
        """
        Given a subtree of the file hierachy, analyze all files/folders within
        and write data back to `self.names`, `self.ncode`, `self.parents`,
        `self.ncomms`, and `self.nlogs` in a way that can be used to generate
        treemaps
        """
        total = NodeInfo.new()
        for key, val in subdata.items():
            self.counts[key] = self.counts.get(key, -1) + 1
            unique_key = f"{key}__{self.counts[key]}"
            if val != {}:
                diff = self.recursively_construct(
                    val, f"{path}/{key}", unique_key, path2data, plot_data
                )
            else:
                full_path = f"{path}/{key}"
                diff = path2data[full_path[1:]]
            plot_data.ids.append(unique_key)
            plot_data.names.append(key)
            plot_data.parents.append(parent_name)
            plot_data.infos.append(diff)
            total += diff
        return total

    def generate_treemap_for_ext(
        self, typ: Literal["comments", "logs"], ext: str
    ) -> go.Figure:
        """
        Creates and returns the treemap figure
        """
        print(f"Generating {typ} plot for .{ext} files...")
        data = self.ext2plotdata[ext]
        fig = px.treemap(
            ids=data.ids,
            names=data.names,
            hover_name=data.names,
            values=[math.log10(thing.lines + 1) for thing in data.infos],
            parents=data.parents,
            color=[
                float(thing.comments if typ == "comments" else thing.logs)
                / (thing.lines if thing.lines > 0 else 1)
                for thing in data.infos
            ],
            color_continuous_scale=["red", "#FFD7D6", "white"],
            range_color=[0, 0.3],
        )
        fig.update_layout(autosize=True)
        return fig


if __name__ == "__main__":
    # Clean up data dir
    shutil.rmtree("data", ignore_errors=True)
    os.mkdir("data")
    os.mkdir("data/logs")
    os.mkdir("data/comments")
    exts = ["*", "py", "java"]
    analyzer = CodeQualityAnalyzer(sys.argv[1], sys.argv[2], exts)
    for ext in exts:
        for typ in ["comments", "logs"]:
            print(typ, ext)
            the_fig = analyzer.generate_treemap_for_ext(typ, ext)
            dump = json.dumps(the_fig, cls=PlotlyJSONEncoder)
            with open(f"data/{typ}/{ext}.json", "w") as fout:
                fout.write(dump)
